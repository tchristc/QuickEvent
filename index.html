<script src="scripts/vue/vue.min.js"></script>

<script type="text/x-template" id="pipeline-template">
  <svg width="100%" height="100%" ref="svgCanvas" >
      <plugin v-for="data in stats" :data="data"></plugin>
  </svg>
</script> 

<script type="text/x-template" id="plugin-template">
  <g class="draggable" style="fill:transparent;stroke:black;stroke-width:1;">
      <rect :x="data.x" :y="data.y" rx="5" ry="5" :width="data.w" :height="data.h"/>
      <line :x1="data.x" :y1="data.x+10" :x2="data.x+data.w" :y2="data.x+10"></line>
  </g>
</script> 

<div id="app">
  <button @click="add">add</button>
  <pipeline :stats="stats"></pipeline>
</div>

<script>
var stats = [
  { label: 'plugin a', x: 3, y: 3, w:100, h:50 },
  { label: 'plugin b', x: 50, y:50, w:100, h:50 }
];

Vue.component('pipeline', {
  props: ['stats'],
  template: '#pipeline-template',
  created: function(){
    console.log('Created');
  },
  mounted: function(){
    console.log('Mounted');
    console.log(this.$refs.svgCanvas);
  }
});

Vue.component('plugin', {
  props: ['data'],
  template: '#plugin-template'
});

var vm = new Vue({
  el: '#app',
  data: {
    stats: stats
  },
  methods: {
    add: function (e) {
      e.preventDefault()
      this.stats.push({
        value: 100
      });
    },
    remove: function (stat) {
      this.stats.splice(this.stats.indexOf(stat), 1)
    }
  }
});
</script>

<style>
body {
    font-family: Helvetica Neue, Arial, sans-serif;
}

polygon {
    fill: #42b983;
    opacity: .75;
}

circle {
    fill: transparent;
    stroke: #999;
}

text {
    font-family: Helvetica Neue, Arial, sans-serif;
    font-size: 10px;
    fill: #666;
}

label {
    display: inline-block;
    margin-left: 10px;
    width: 20px;
}

#raw {
    position: absolute;
    top: 0;
    left: 300px;
}

.draggable {
  cursor: move;
}
</style>
<script type="text/javascript">
  function makeDraggable(evt) {
    var svg = evt.target;
    svg.addEventListener('mousedown', startDrag, false);
    svg.addEventListener('mousemove', drag, false);
    svg.addEventListener('mouseup', endDrag, false);
    svg.addEventListener('mouseleave', endDrag);

    function getMousePosition(evt) {
      var CTM = svg.getScreenCTM();
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    var selectedElement, offset, transform;

    function startDrag(evt) {
      if (evt.target.classList.contains('draggable')) {
        selectedElement = evt.target;
        offset = getMousePosition(evt);

        // Make sure the first transform on the element is a translate transform
        var transforms = selectedElement.transform.baseVal;

        if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
          // Create an transform that translates by (0, 0)
          var translate = svg.createSVGTransform();
          translate.setTranslate(0, 0);
          selectedElement.transform.baseVal.insertItemBefore(translate, 0);
        }

        // Get initial translation
        transform = transforms.getItem(0);
        offset.x -= transform.matrix.e;
        offset.y -= transform.matrix.f;
      }
    }

    function drag(evt) {
      if (selectedElement) {
        evt.preventDefault();
        var coord = getMousePosition(evt);
        transform.setTranslate(coord.x - offset.x, coord.y - offset.y);
      }
    }

    function endDrag(evt) {
      selectedElement = false;
    }
  }
 </script>