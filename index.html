<script src="scripts/vue/vue.min.js"></script>
<script type="text/x-template" id="pipeline-template">
  <plugin
    v-for="(p, i) in plugins"
    :data="p">
  </plugin>
</script> 

<script type="text/x-template" id="plugin-template">
  <g class="draggable" style="fill:transparent;stroke:black;stroke-width:1;">
      <rect x="3" y="3" rx="10" ry="10" width="50" height="50"/>
      <line x1="3" y1="13" x2="53" y2="13"></line>
  </g>
</script> 

<div id="app">
  <svg width="100%" height="100%" onload="makeDraggable(evt)">
    <pipeline :plugins="plugins"></pipeline>
  </svg>
  <!-- controls -->
  <!-- <div v-for="stat in stats">
    <label>{{stat.label}}</label>
    <input type="range" v-model="stat.value" min="0" max="100">
    <span>{{stat.value}}</span>
    <button @click="remove(stat)" class="remove">X</button>
  </div>
  <form id="add">
    <input name="newlabel" v-model="newLabel">
    <button @click="add">Add a Stat</button>
  </form>
  <pre id="raw">{{ stats }}</pre> -->
</div>

<script>
var plugins = [
  { label: 'plugin a', x: 3, y: 3, w:50, h:50 }
]

// A resusable polygon graph component
Vue.component('pipeline', {
  props: ['plugins'],
  template: '#pipeline-template',
  components: {
    // a sub component for the labels
    'plugin': {
      props: {
        data: Object
      },
      template: '#plugin-template'
      // computed: {
      //   point: function () {
      //     return valueToPoint(
      //       +this.stat.value + 10,
      //       this.index,
      //       this.total
      //     )
      //   }
      // }
    }
  }
});

new Vue({
  el: '#app',
  data: {
    plugins: plugins
  }
  // methods: {
  //   add: function (e) {
  //     e.preventDefault()
  //     if (!this.newLabel) return
  //     this.stats.push({
  //       label: this.newLabel,
  //       value: 100
  //     })
  //     this.newLabel = ''
  //   },
  //   remove: function (stat) {
  //     if (this.stats.length > 3) {
  //       this.stats.splice(this.stats.indexOf(stat), 1)
  //     } else {
  //       alert('Can\'t delete more!')
  //     }
  //   }
  // }
});
</script>

<style>
body {
    font-family: Helvetica Neue, Arial, sans-serif;
}

polygon {
    fill: #42b983;
    opacity: .75;
}

circle {
    fill: transparent;
    stroke: #999;
}

text {
    font-family: Helvetica Neue, Arial, sans-serif;
    font-size: 10px;
    fill: #666;
}

label {
    display: inline-block;
    margin-left: 10px;
    width: 20px;
}

#raw {
    position: absolute;
    top: 0;
    left: 300px;
}

.draggable {
  cursor: move;
}
</style>
<script type="text/javascript">
  function makeDraggable(evt) {
    var svg = evt.target;
    svg.addEventListener('mousedown', startDrag, false);
    svg.addEventListener('mousemove', drag, false);
    svg.addEventListener('mouseup', endDrag, false);
    svg.addEventListener('mouseleave', endDrag);

    function getMousePosition(evt) {
      var CTM = svg.getScreenCTM();
      return {
        x: (evt.clientX - CTM.e) / CTM.a,
        y: (evt.clientY - CTM.f) / CTM.d
      };
    }

    var selectedElement, offset, transform;

    function startDrag(evt) {
      if (evt.target.classList.contains('draggable')) {
        selectedElement = evt.target;
        offset = getMousePosition(evt);

        // Make sure the first transform on the element is a translate transform
        var transforms = selectedElement.transform.baseVal;

        if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
          // Create an transform that translates by (0, 0)
          var translate = svg.createSVGTransform();
          translate.setTranslate(0, 0);
          selectedElement.transform.baseVal.insertItemBefore(translate, 0);
        }

        // Get initial translation
        transform = transforms.getItem(0);
        offset.x -= transform.matrix.e;
        offset.y -= transform.matrix.f;
      }
    }

    function drag(evt) {
      if (selectedElement) {
        evt.preventDefault();
        var coord = getMousePosition(evt);
        transform.setTranslate(coord.x - offset.x, coord.y - offset.y);
      }
    }

    function endDrag(evt) {
      selectedElement = false;
    }
  }
 </script>