<script src="scripts/vue/vue.min.js"></script>
<style>
    text {
        font-family: Helvetica Neue, Arial, sans-serif;
        font-size: 10px;
        fill: #000;
    }

    #svgCanvas{
      background-color:#999;
    }    

    .draggable {
      cursor: move;
    }

    .animated {
      -webkit-animation-duration: 1s;
      animation-duration: 1s;
    }

    @keyframes pulse {
      from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
      }
      50% {
        -webkit-transform: scale3d(1.05, 1.05, 1.05);
        transform: scale3d(1.05, 1.05, 1.05);
      }
      to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
      }
    }

    .plugin {
      fill:rgba(255,255,255,.25);
      stroke:black;
      stroke-width:.5;
    }

    .plugin .animated{
      animation: pulse 1s infinite;
      /* transform-origin: center center; */
    }

    
    .plugin-connector {
      fill:lightgreen;
      stroke:black;
      stroke-width:.5;
    }

    .connector-line {
      fill:lightgreen;
      stroke:black;
      stroke-width:.5; 
    }

    @keyframes circle-zoom-in {
      from {
        r: 2;
      }

      to {
        r: 4;
      }
    }

    .plugin-connector:hover {
      fill:lightgreen;
      stroke:black;
      stroke-width:.5;
      cursor:pointer;
      animation: circle-zoom-in .25s forwards;
    }
</style>

<script type="text/x-template" id="pipeline-template">
  <svg width="100%" height="100%" id="svgCanvas" 
    @mousemove="movePointer">
      <plugin v-for="plugin in appData.plugins" :data="plugin" :pointer="pointer" ref="plugins" ></plugin>
  </svg>
</script> 

<script type="text/x-template" id="plugin-template">
  <g>
    <plugin-processor :data="data" ref="plugin-processors" ></plugin-processor>
    <plugin-connector-in :data="data" ref="plugin-connectors-ins" ></plugin-connector-in>
    <plugin-connector-out :data="data" :pointer="pointer" ref="plugin-connector-outs" ></plugin-connector-out>
  </g>
</script>

<script type="text/x-template" id="plugin-processor-template">
  <svg class="plugin" v-bind="pluginPos"
    @mousedown.prevent="startMove" 
    @touchstart.prevent="startMove">
    <g>
        <rect x="1" y="1" rx="5" ry="5" :width="data.w" :height="data.h"/>
        <line x1="1" y1="10" :x2="data.w+1" y2="10"></line>
        <line x1="1" y1="20" :x2="data.w+1" y2="20"></line>
        <text x="30" y="10">Component</text>
        <text x="2" y="20">Input</text>
        <text x="69" y="20">Output</text>
    </g>
  </svg>
</script>

<script type="text/x-template" id="plugin-connector-out-template">
  <svg
    @mousedown.prevent="startMove" 
    @touchstart.prevent="startMove">
    <g>
      <circle class="plugin-connector" :cx="data.x+data.w+(3+data.r)" :cy="data.y+16" :r="data.r" />
      <line class="connector-line" :x1="data.x+data.w+(3+data.r)" :y1="data.y+16" :x2="pointer.x" :y2="pointer.y" ref="connector-line" :visibility="visibility()"> </line>
    </g>
  </svg>
</script>

<script type="text/x-template" id="plugin-connector-in-template">
  <circle class="plugin-connector" :cx="data.x-(1+data.r)" :cy="data.y+16" :r="data.r" />
</script>

<div id="app">
  <button @click="add">add</button>
  <pipeline :appData="appData"></pipeline>
</div>

<script>
  var appData = {
      plugins: [
      { x: 3, y: 3 },
      { x: 50, y:50 }
    ]
  };

var draggableMixins = {
  props: ['touch', 'events', 'moving', 'elem', 'transform'],
  methods: {
    startMove(evt) {
			this.touch = (evt.type === "touchstart");
			if (!this.touch && evt.button !== 0) return;
			this.events = this.touch ? { move: "touchmove", stop: "touchend"} : { move: "mousemove", stop: "mouseup"};
      
			this.elem = document.querySelector("#svgCanvas");
      this.point = this.elem.createSVGPoint()
      
      this.transform = this.elem.getScreenCTM().inverse()
			
      this.getPos(evt)

      var CTM = this.$el.getScreenCTM();
      this.offset = {x: (evt.clientX - CTM.e) , y: (evt.clientY - CTM.f)}

      this.moving = true
			requestAnimationFrame(this.updateFn)
      this.moveFn(evt)
      
			this.elem.addEventListener(this.events.move, this.moveFn)
			this.elem.addEventListener(this.events.stop, this.stopFn)
    },
    updateFn: function() {
      if (this.moving) requestAnimationFrame(this.updateFn)

      var newPt = this.point.matrixTransform(this.transform)
      this.data.x = newPt.x
      this.data.y = newPt.y
    },
    moveFn: function (evt){
      this.getPos(evt)

      this.point.x -= this.offset.x
      this.point.y -= this.offset.y
    },
    stopFn: function(evt) {
      this.moving = false
      this.elem.removeEventListener(this.events.move, this.moveFn)
      this.elem.removeEventListener(this.events.stop, this.stopFn)
    },
    getPos: function (evt) {
      return this.touch ? this.getTouchPos(evt) : this.getMousePos(evt);
    },
    getMousePos: function (mouseEvent) {
      this.point.x = (mouseEvent.clientX);
      this.point.y = (mouseEvent.clientY);
    },
    getTouchPos: function (touchEvent) {
      this.point.x = (touchEvent.touches[0].clientX);
      this.point.y = (touchEvent.touches[0].clientY);
    }
  }
}

Vue.component('pipeline', {
  props: ['plugins', 'point', 'pointer'],
  template: '#pipeline-template',
  created: function(){
    
    this.point = {x:0,y:0};
    this.pointer = {x:0,y:0};
  },
  mounted: function(){
  },
  methods:{
    movePointer: function(evt){
      this.getPos(evt);
      this.pointer.x = evt.clientX-8;
      this.pointer.y = evt.clientY-30
    }
  },
  mixins: [draggableMixins],
});

Vue.component('plugin', {
  props: ['data', 'pointer'],
  template: '#plugin-template',
  created: function(){
  },
  updated: function(){
  },
  methods: {
  },
  mixins: [draggableMixins],
});

Vue.component('plugin-processor', {
  props: ['data'],
  template: '#plugin-processor-template',
  created: function(){
    this.data.w = 100;
    this.data.h = 30;
    this.data.r = 2;
  },
  updated: function(){
  },
  methods: {
  },
  computed: {
    pluginPos: function(){
      return {
        x: this.data.x,
        y: this.data.y
      }
    }
  },
  mixins: [draggableMixins],
});

Vue.component('plugin-connector-in', {
  props: ['data'],
  template: '#plugin-connector-in-template'
});

Vue.component('plugin-connector-out', {
  props: ['data', 'pointer',
      'touch', 'events', 'moving', 'elem', 'transform', 'point'],
  template: '#plugin-connector-out-template',
  created: function(){
  },
  mounted: function(){
    this.elem = document.querySelector("#svgCanvas");
    this.point = this.elem.createSVGPoint();
  },
  methods: {
    startMove(evt) {
      this.touch = (evt.type === "touchstart");
			if (!this.touch && evt.button !== 0) return;
			this.events = this.touch ? { move: "touchmove", stop: "touchend"} : { move: "mousemove", stop: "mouseup"};
      
      this.moving = true
			requestAnimationFrame(this.updateFn)
      this.moveFn(evt)
      
			this.elem.addEventListener(this.events.move, this.moveFn)
			this.elem.addEventListener(this.events.stop, this.stopFn)
    },
    updateFn: function() {
    },
    moveFn: function (evt){

    },
    stopFn: function(evt) {
      this.moving = false
      this.elem.removeEventListener(this.events.move, this.moveFn)
      this.elem.removeEventListener(this.events.stop, this.stopFn)
    },
    getPos: function (evt) {
      return this.touch ? this.getTouchPos(evt) : this.getMousePos(evt);
    },
    getMousePos: function (mouseEvent) {
      this.point.x = (mouseEvent.clientX);
      this.point.y = (mouseEvent.clientY);
    },
    getTouchPos: function (touchEvent) {
      this.point.x = (touchEvent.touches[0].clientX);
      this.point.y = (touchEvent.touches[0].clientY);
    },
    visibility: function(){
      return this.moving ? 'visible' : 'hidden';
    }
  }
});

var vm = new Vue({
  el: '#app',
  data: {
    appData: appData
  },
  methods: {
    add: function (e) {
      e.preventDefault();
      this.appData.plugins.push({ x: 3, y: 3, w:100, h:50 });
    },
    remove: function (stat) {
      this.appData.plugins.splice(this.plugins.indexOf(stat), 1);
    }
  },
  mixins: [draggableMixins],
});
</script>