<script src="scripts/vue/vue.min.js"></script>
<style>
    body {
        font-family: Helvetica Neue, Arial, sans-serif;
    }
    
    polygon {
        fill: #42b983;
        opacity: .75;
    }
    
    circle {
        fill: transparent;
        stroke: #999;
    }
    
    text {
        font-family: Helvetica Neue, Arial, sans-serif;
        font-size: 10px;
        fill: #666;
    }
    
    label {
        display: inline-block;
        margin-left: 10px;
        width: 20px;
    }
    
    #raw {
        position: absolute;
        top: 0;
        left: 300px;
    }
    
    .draggable {
      cursor: move;
    }

    .animated {
      -webkit-animation-duration: 1s;
      animation-duration: 1s;
    }

    @keyframes pulse {
      from {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
      }
      50% {
        -webkit-transform: scale3d(1.05, 1.05, 1.05);
        transform: scale3d(1.05, 1.05, 1.05);
      }
      to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
      }
    }

    .plugin {
      fill:rgba(0,0,0,.25);
      stroke:black;
      stroke-width:.5;
    }

    .plugin .animated{
      animation: pulse 1s infinite;
      /* transform-origin: center center; */
    }

    
    .plugin-connector {
      fill:lightgreen;
      stroke:black;
      stroke-width:.5;
      transition: all 1s ease-in-out;
    }

    @keyframes circle-zoom-in {
      from {
        r: 2;
      }

      to {
        r: 4;
      }
    }

    .plugin-connector:hover {
      fill:lightgreen;
      stroke:black;
      stroke-width:.5;
      cursor:pointer;
      animation: circle-zoom-in .5s forwards;
    }
</style>
<script type="text/x-template" id="pipeline-template">
  <svg width="100%" height="100%" id="svgCanvas" >
      <plugin v-for="plugin in plugins" :data="plugin" ref="plugins" ></plugin>
  </svg>
</script> 
<script type="text/x-template" id="plugin-template">
  <svg class="plugin" v-bind="pluginPos"
    @mousedown.prevent="startMove" 
    @touchstart.prevent="startMove">
    <g>
        <rect x="7" y="1" rx="5" ry="5" :width="data.w" :height="data.h"/>
        <line x1="7" y1="10" :x2="data.w+7" y2="10"></line>
        <line x1="7" y1="20" :x2="data.w+7" y2="20"></line>
        <text x="30" y="10">Component</text>
        <text x="10" y="20">Input</text>
        <text x="75" y="20">Output</text>
        <circle class="plugin-connector" cx="3" cy="16" r="2" />
        <circle class="plugin-connector" :cx="data.w+11" cy="16" r="2" />    
    </g>
  </svg>
</script> 

<div id="app">
  <button @click="add">add</button>
  <pipeline :plugins="plugins"></pipeline>
</div>

<script>
var plugins = [
  { x: 3, y: 3, w:100, h:30 },
  { x: 50, y:50, w:100, h:30 }
];

var draggableMixins = {
  methods: {
  startMove(evt) {
			const touch = (evt.type === "touchstart")
			if (!touch && evt.button !== 0) return;
			const events = touch ? {
				move: "touchmove",
				stop: "touchend"
			} : {
				move: "mousemove",
				stop: "mouseup"
			}
      
			const elem = document.querySelector("#svgCanvas");
      const point = elem.createSVGPoint()
			const transform = elem.getScreenCTM().inverse()
			const getPos = touch ? getTouchPos : getMousePos
      getPos(evt, point)

      var CTM = this.$el.getScreenCTM();
      var offset = {x: (evt.clientX - CTM.e) , y: (evt.clientY - CTM.f)}

      var moving = true
			var newPt 

			const updateFn = () => {
        if (moving) requestAnimationFrame(updateFn)

				newPt = point.matrixTransform(transform)
				this.data.x = newPt.x
				this.data.y = newPt.y
      }
      
			const moveFn = (evt) => {
        getPos(evt, point)

        point.x -= offset.x
        point.y -= offset.y
      }
			const stopFn = (evt) => {
				moving = false
				elem.removeEventListener(events.move, moveFn)
				elem.removeEventListener(events.stop, stopFn)
			}

			requestAnimationFrame(updateFn)
      moveFn(evt)
      
			elem.addEventListener(events.move, moveFn)
			elem.addEventListener(events.stop, stopFn)
		}
  }
}

Vue.component('pipeline', {
  props: ['plugins'],
  template: '#pipeline-template',
  mixins: [draggableMixins],
});

Vue.component('plugin', {
  props: ['data'],
  template: '#plugin-template',
  created: function(){
  },
  methods: {
    
  },
  computed: {
    pluginPos: function(){
      return {
        x: this.data.x,
        y: this.data.y
      }
    }
  },
  mixins: [draggableMixins],
});

var vm = new Vue({
  el: '#app',
  data: {
    plugins: plugins
  },
  methods: {
    add: function (e) {
      e.preventDefault();
      this.plugins.push({ x: 3, y: 3, w:100, h:50 });
    },
    remove: function (stat) {
      this.plugins.splice(this.plugins.indexOf(stat), 1);
    }
  },
  mixins: [draggableMixins],
});

function getMousePos(mouseEvent, point) {
	point.x = (mouseEvent.clientX)
	point.y = (mouseEvent.clientY)
}

function getTouchPos(touchEvent, point) {
	point.x = (touchEvent.touches[0].clientX)
	point.y = (touchEvent.touches[0].clientY)
}
</script>